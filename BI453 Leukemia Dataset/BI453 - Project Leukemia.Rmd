---
title: "BI453 - Project Leukemia"
output: html_document
date: "2024-01-25"
---
```{r include=FALSE}
#Required packages
library(Biobase)
library(mclust)
library(clue)
library(pdfCluster)
library(NMF)
library(funtimes)
library(ggplot2)
library(plotrix)
library(fpc)
library(cluster)
library(mclust)
library(aricode)
library(dplyr)
library(corrplot)
```


```{r}
#Read in gene expression data and covert it to matrix formation
exprs <- as.matrix(read.table("ALL_AML_data_matrix.txt", header = TRUE, row.names = 1, sep = "\t", as.is = TRUE))

#Read in the file containing phenotypic data i.e. samples
pData <-(read.table("ALL_AML_samples2.txt", row.names = 1, header = FALSE, sep = "\t"))

#Read in the file containing feature data i.e. genes
fData <- (read.delim("ALL_AML_genes.txt", row.names = 1, header = TRUE, sep = "\t"))
```

```{r}
#Makes an expression set from the expression matrix, phenotype data (sample), feature data (gene)
eset <- ExpressionSet(assayData = exprs,
                      phenoData = AnnotatedDataFrame(pData),
                      featureData = AnnotatedDataFrame(fData))

#Inspect dimensions of eset
dim(eset)
```

```{r}
#Assign the expression matrix as 'A'
A <- exprs(eset)
```


Ground Truth Labels for Leukemia Dataset
```{r}
#Function to map cluster predictions to ground truths
unify_labels <- function(predictcluster, T) {
  match(predictcluster, unique(predictcluster))
}

#Assign the column names of the expression matrix to 'samples'
samples <- colnames(exprs)

#Creating a vector with the ground truths for all samples, when k=2
True_labels1 <- c(1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2)
Truelabel1samples <- data.frame(
  Sample = samples,
  True_labels1 = True_labels1)

#Creating a vector with the ground truths for all samples, when k=3
True_labels2 <- c(1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,1 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3 ,3)
Truelabel2samples <- data.frame(
  Sample = samples,
  True_Labels2 = True_labels2)
```

Basic NMF and cluster predictions
```{r}
#Assign the maximum Value of A to 'maxA'
maxA <- max(A)

#Create a list of 100 matrices for each value of noise 'r', from 0 to 1 in increments of 0.05, where each matrix is generated by adding a scaled random matrix to the original matrix 'A'
matrix_list <- list()
for (r in seq(0, 1, by = 0.05)) {
  matrix_list[[as.character(r)]] <- list()
  for (x in 1:100) {
    new_matrix <- A + r * (matrix(runif(5000 * 38), nrow = 5000, ncol = 38) * maxA)
    matrix_list[[as.character(r)]][[as.character(x)]] <- new_matrix
  }
}

#Run NMF on each matrix generated above for both k=2 and k=3 and assign the results to 'nmf_results1' and 'nmf_results2.
nmf_results1 <- list()
nmf_results2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  nmf_results1[[as.character(r)]] <- list()
  nmf_results2[[as.character(r)]] <- list()
  for (x in 1:100) {
  current_matrix <- matrix_list[[as.character(r)]][[as.character(x)]]
  #k=2
  nmf_result1 <- nmf(current_matrix, 2, nrun = 2, seed = "random")
  #k=3
  nmf_result2 <- nmf(current_matrix, 3, nrun = 2, seed = "random")
  nmf_results1[[as.character(r)]][[as.character(x)]] <- nmf_result1
  nmf_results2[[as.character(r)]][[as.character(x)]] <- nmf_result2
  }
}

#Use the predict function to make cluster predictions for each nmf result from above. Use the unify_labels function to map cluster predictions to ground truths
predictions1 <- list()
predictions2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  predictions1[[as.character(r)]] <- list()
  predictions2[[as.character(r)]] <- list()
  for (x in 1:100) {
  cluster_predictions1 <- (nmf_results1[[as.character(r)]][[x]])
  cluster_predictions2 <- (nmf_results2[[as.character(r)]][[x]])
  #k=2
  clusterpredict1 <- unify_labels((predict(cluster_predictions1)), True_labels1)
  #k=3
  clusterpredict2 <- unify_labels((predict(cluster_predictions2)), True_labels2)
  predictions1[[as.character(r)]][[as.character(x)]] <- clusterpredict1
  predictions2[[as.character(r)]][[as.character(x)]] <- clusterpredict2
  }
}
```

Purity
```{r}
#Calculate the purity for cluster predictions made above and assign to 'puritylist1' and 'puritylist2'
puritylist1 <- list()
puritylist2 <- list()
for (r in seq(0,1, by = 0.05)) {
  puritylist1[[as.character(r)]] <- list()
  puritylist2[[as.character(r)]] <- list()
  for (x in 1:100) {
  purity_results1 <- predictions1[[as.character(r)]][[x]]
  purity_results2 <- predictions2[[as.character(r)]][[x]]
  #k=2
  puritymeasure1 <- purity(purity_results1, True_labels1)
  #k=3
  puritymeasure2 <- purity(purity_results2, True_labels2)
  puritylist1[[as.character(r)]][[as.character(x)]] <- puritymeasure1
  puritylist2[[as.character(r)]][[as.character(x)]] <- puritymeasure2
  }
}

#Calculate the mean purity and standard error of the mean (SEM) for each value of r across all 100 matrices and assign to 'purityaverage1', 'purityaverage2', 'sempurity1' and 'sempurity2'
purityaverage1 <- list()
purityaverage2 <- list()
sempurity1 <- list()
sempurity2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  #k=2
  purities1 <- sapply(1:100, function(x) puritylist1[[as.character(r)]][[as.character(x)]]$pur)
  #k=3
  purities2 <- sapply(1:100, function(x) puritylist2[[as.character(r)]][[as.character(x)]]$pur)
  purityaverage1[[as.character(r)]] <- mean(unlist(purities1))
  purityaverage2[[as.character(r)]] <- mean(unlist(purities2))
  sempurity1[[as.character(r)]] <- std.error(unlist(purities1))
  sempurity2[[as.character(r)]] <- std.error(unlist(purities2))
}

#Create a table of average purity values for each value of r, when k=2
Accuracypurity_table1 <- data.frame(
  r = seq(0, 1, by = 0.05),
  Averagepurity1 = unlist(purityaverage1),
  sempurity1 = unlist(sempurity1)
)

#Create a table of average purity values for each value of r, when k=3
Accuracypurity_table2 <- data.frame(
  r = seq(0, 1, by = 0.05),
  Averagepurity2 = unlist(purityaverage2),
  sempurity2 = unlist(sempurity2)
)

#Inspect average purity tables
Accuracypurity_table1
Accuracypurity_table2
```

Adjusted Rand Index
```{r}
#Calculate the adjusted rand index for cluster predictions made above and assign to 'ARI1' and 'ARI2'
ARI1 <- list()
ARI2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  ARI1[[as.character(r)]] <- list()
  ARI2[[as.character(r)]] <- list()
  for (x in 1:100) {
  ARI_results1 <- predictions1[[as.character(r)]][[as.character(x)]]
  ARI_results2 <- predictions2[[as.character(r)]][[as.character(x)]]
  #k=2
  ARIpredict1 <- adjustedRandIndex(ARI_results1, True_labels1)
  #k=3
  ARIpredict2 <- adjustedRandIndex(ARI_results2, True_labels2)
  ARI1[[as.character(r)]][[as.character(x)]] <- ARIpredict1
  ARI2[[as.character(r)]][[as.character(x)]] <- ARIpredict2
  }
}

#Calculate the mean ARI and SEM for each value of r across all 100 matrices and assign to 'average_ARI1','average_ARI1','semari1' and 'semari2'
average_ARI1 <- list()
average_ARI2 <- list()
semari1 <- list()
semari2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  ariaverages1 <- sapply(1:100, function(x) ARI1[[as.character(r)]][[as.character(x)]])
  ariaverages2 <- sapply(1:100, function(x) ARI2[[as.character(r)]][[as.character(x)]])
  #k=2
  average_ARI1[[as.character(r)]] <- mean(unlist(ariaverages1))
  #k=3
  average_ARI2[[as.character(r)]] <- mean(unlist(ariaverages2))
  semari1[[as.character(r)]] <- std.error(unlist(ariaverages1))
  semari2[[as.character(r)]] <- std.error(unlist(ariaverages2))
}

#Create a table of average adjusted rand index values for each value of r, when k=2
ARI_table1 <- data.frame(
  r = seq(0, 1, by = 0.05),
  average_ARI1 = unlist(average_ARI1)
)

#Create a table of average adjusted rand index values for each value of r, when k=3
ARI_table2 <- data.frame(
  r = seq(0, 1, by = 0.05),
  average_ARI2 = unlist(average_ARI2)
)
```

Normalised Mutual Information
```{r}
#Calculate the normalised mutual information for cluster predictions made above and assign to 'NMIs1' and 'NMIs2'
NMIs1 <- list()
NMIs2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  NMIs1[[as.character(r)]] <- list()
  NMIs2[[as.character(r)]] <- list()
  for (x in 1:100) {
    NMI_results1 <- predictions1[[as.character(r)]][[as.character(x)]]
    NMI_results2 <- predictions2[[as.character(r)]][[as.character(x)]]
    #k=2
    NMIpredict1 <- NMI(NMI_results1, True_labels1)
    #k=3
    NMIpredict2 <- NMI(NMI_results2, True_labels2)
    NMIs1[[as.character(r)]][[as.character(x)]] <- NMIpredict1
    NMIs2[[as.character(r)]][[as.character(x)]] <- NMIpredict2
  }
}

#Calculate the mean normalised mutual information and SEM for each value of r across all 100 matrices and assign to 'average_NMI1','average_NMI2','semnmi1' and 'semnmi2'
average_NMI1 <- list()
average_NMI2 <- list()
semnmi1 <- list()
semnmi2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  nmiaverages1 <- sapply(1:100, function(x) NMIs1[[as.character(r)]][[as.character(x)]])
  nmiaverages2 <- sapply(1:100, function(x) NMIs2[[as.character(r)]][[as.character(x)]])
  #k=2
  average_NMI1[[as.character(r)]] <- mean(unlist(nmiaverages1))
  #k=3
  average_NMI2[[as.character(r)]] <- mean(unlist(nmiaverages2))
  semnmi1[[as.character(r)]] <- std.error(unlist(nmiaverages1))
  semnmi2[[as.character(r)]] <- std.error(unlist(nmiaverages2))
}

#Create a table of average normalised mutual information values for each value of r, when k=2
NMI_table1 <- data.frame(
  r = seq(0, 1, by = 0.05),
  average_NMI1 = unlist(average_NMI1)
)

#Create a table of average normalised mutual information values for each value of r, when k=2
NMI_table2 <- data.frame(
  r = seq(0, 1, by = 0.05),
  average_NMI2 = unlist(average_NMI2)
)
```

Post-Processing method - Normalisation
```{r}
#Post-processing
#Extract the basis and coefficient matrices, W and H, from the nmf results above 
W_matrices1 <- list()
W_matrices2 <- list()
W2_matrices1 <- list()
W2_matrices2 <- list()
for(r in seq(0, 1, by = 0.05)) {
  W_matrices1[[as.character(r)]] <- list()
  W_matrices2[[as.character(r)]] <- list()
  W2_matrices1[[as.character(r)]] <- list()
  W2_matrices2[[as.character(r)]] <- list()
  for (x in 1:100) {
  NMFinput1 <- (nmf_results1[[as.character(r)]])[[x]]
  NMFinput2 <- (nmf_results2[[as.character(r)]])[[x]]
  #k=2
  Wmatrixgen1 <- basis(NMFinput1)
  #k=3
  Wmatrixgen2 <- basis(NMFinput2)
  W_matrices1[[as.character(r)]][[as.character(x)]] <- Wmatrixgen1
  W_matrices2[[as.character(r)]][[as.character(x)]] <- Wmatrixgen2
  W2_matrices1[[as.character(r)]][[as.character(x)]] <- Wmatrixgen1
  W2_matrices2[[as.character(r)]][[as.character(x)]] <- Wmatrixgen2
  }
}
  
H_matrices1 <- list()
H_matrices2 <- list()
H2_matrices1 <- list()
H2_matrices2 <- list()
for(r in seq(0, 1, by = 0.05)) {
  H_matrices1[[as.character(r)]] <- list()
  H_matrices2[[as.character(r)]] <- list()
  H2_matrices1[[as.character(r)]] <- list()
  H2_matrices2[[as.character(r)]] <- list()
  for (x in 1:100) {
  NMFinput1.1 <- (nmf_results1[[as.character(r)]])[[x]]
  NMFinput2.1 <- (nmf_results2[[as.character(r)]])[[x]]
  #k=2
  Hmatrixgen1 <- coef(NMFinput1.1)
  #k=3
  Hmatrixgen2 <- coef(NMFinput2.1)
  H_matrices1[[as.character(r)]][[as.character(x)]] <- Hmatrixgen1
  H_matrices2[[as.character(r)]][[as.character(x)]] <- Hmatrixgen2
  H2_matrices1[[as.character(r)]][[as.character(x)]] <- Hmatrixgen1
  H2_matrices2[[as.character(r)]][[as.character(x)]] <- Hmatrixgen2
  }
}

#Divide all columns of W by the maximum value in that column and multiply the rows of H by the corresponding value of W
#k=2
for (r in seq(0, 1, by = 0.05)) {
  for (x in 1:100) {
  max_values <- apply((W2_matrices1[[as.character(r)]][[as.character(x)]]), 2, max)
  W2_matrices1[[as.character(r)]][[as.character(x)]] <- (W2_matrices1[[as.character(r)]][[as.character(x)]]) / max_values
  H2_matrices1[[as.character(r)]][[as.character(x)]] <- (H2_matrices1[[as.character(r)]][[as.character(x)]]) * max_values
  }
}
#k=3
for (r in seq(0, 1, by = 0.05)) {
  for (x in 1:100) {
  max_values2 <- apply((W2_matrices2[[as.character(r)]][[as.character(x)]]), 2, max)
  W2_matrices2[[as.character(r)]][[as.character(x)]] <- (W2_matrices2[[as.character(r)]][[as.character(x)]])  / max_values2
  H2_matrices2[[as.character(r)]][[as.character(x)]] <- (H2_matrices2[[as.character(r)]][[as.character(x)]])  * max_values2
  }
}

#Make cluster predictions using the coefficient matrices H extracted above. A sample j is placed in cluster i if hij is the largest entry in column j.
#k=2
predicted_clusters <- list()
H2.1_clusters <- list()
for (r in seq(0, 1, by = 0.05)) {
  for (x in 1:100) {
    H_matrix <- H2_matrices1[[as.character(r)]][[as.character(x)]]
    cluster_assignments <- apply(H_matrix, 2, which.max)
    predicted_clusters[[as.character(r)]][[as.character(x)]] <- cluster_assignments
    unifyingclusters <- unify_labels((predicted_clusters[[as.character(r)]][[as.character(x)]]), True_labels1)
    H2.1_clusters[[as.character(r)]][[as.character(x)]] <- unifyingclusters
  }
}

#k=3
predicted_clusters2 <- list()
H2.2_clusters <- list()
for (r in seq(0, 1, by = 0.05)) {
  for (x in 1:100) {
    H_matrix2 <- H2_matrices2[[as.character(r)]][[as.character(x)]]
    cluster_assignments2 <- apply(H_matrix2, 2, which.max)
    predicted_clusters2[[as.character(r)]][[as.character(x)]] <- cluster_assignments2
    unifyingclusters2 <- unify_labels((predicted_clusters2[[as.character(r)]][[as.character(x)]]), True_labels2)
    H2.2_clusters[[as.character(r)]][[as.character(x)]] <- unifyingclusters2
  }
}
```

Post-Processing - Purity
```{r}
#The following code is the same as that used above for calculating the purity however, inputs are all post-processing
puritylist2.1 <- list()
puritylist2.2 <- list()
for (r in seq(0,1, by = 0.05)) {
  puritylist2.1[[as.character(r)]] <- list()
  puritylist2.2[[as.character(r)]] <- list()
  for (x in 1:100) {
  purity_results2.1 <- H2.1_clusters[[as.character(r)]][[as.character(x)]]
  purity_results2.2 <- H2.2_clusters[[as.character(r)]][[as.character(x)]]
  #k=2
  puritymeasure2.1 <- purity(True_labels1, purity_results2.1)
  #k=3
  puritymeasure2.2 <- purity(True_labels2, purity_results2.2)
  puritylist2.1[[as.character(r)]][[as.character(x)]] <- puritymeasure2.1
  puritylist2.2[[as.character(r)]][[as.character(x)]] <- puritymeasure2.2
  }
}

purityaverage2.1 <- list()
purityaverage2.2 <- list()
sempurity2.1 <- list()
sempurity2.2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  purities2.1 <- sapply(1:100, function(x) puritylist2.1[[as.character(r)]][[as.character(x)]]$pur)
  purities2.2 <- sapply(1:100, function(x) puritylist2.2[[as.character(r)]][[as.character(x)]]$pur)
  #k=2
  purityaverage2.1[[as.character(r)]] <- mean(unlist(purities2.1))
  #k=3
  purityaverage2.2[[as.character(r)]] <- mean(unlist(purities2.2))
  sempurity2.1[[as.character(r)]] <- std.error(unlist(purities2.1))
  sempurity2.2[[as.character(r)]] <- std.error(unlist(purities2.2))
}
#k=2
Accuracypurity_table2.1 <- data.frame(
  r = seq(0, 1, by = 0.05),
  Averagepurity2.1 = unlist(purityaverage2.1),
  sempurity2.1 = unlist(sempurity2.1)
)
#k=3
Accuracypurity_table2.2 <- data.frame(
  r = seq(0, 1, by = 0.05),
  Averagepurity2.2 = unlist(purityaverage2.2),
  sempurity2.2 = unlist(sempurity2.2)
)
```

Post-Processing - Adjusted Rand Index
```{r}
#The following code is the same as that used above for calculating the adjusted rand index however, inputs are all post-processing
ARI2.1 <- list()
ARI2.2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  ARI2.1[[as.character(r)]] <- list()
  ARI2.2[[as.character(r)]] <- list()
  for (x in 1:100) {
  ARI_results2.1 <- H2.1_clusters[[as.character(r)]][[as.character(x)]]
  ARI_results2.2 <- H2.2_clusters[[as.character(r)]][[as.character(x)]]
  #k=2
  ARIpredict2.1 <- adjustedRandIndex(ARI_results2.1, True_labels1)
  #k=3
  ARIpredict2.2 <- adjustedRandIndex(ARI_results2.2, True_labels2)
  ARI2.1[[as.character(r)]][[as.character(x)]] <- ARIpredict2.1
  ARI2.2[[as.character(r)]][[as.character(x)]] <- ARIpredict2.2
  }
}

average_ARI2.1 <- list()
average_ARI2.2 <- list()
semari2.1 <- list()
semari2.2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  ariaverages2.1 <- sapply(1:100, function(x) ARI2.1[[as.character(r)]][[as.character(x)]])
  ariaverages2.2 <- sapply(1:100, function(x) ARI2.2[[as.character(r)]][[as.character(x)]])
  #k=2
  average_ARI2.1[[as.character(r)]] <- mean(unlist(ariaverages2.1))
  #k=3
  average_ARI2.2[[as.character(r)]] <- mean(unlist(ariaverages2.2))
  semari2.1[[as.character(r)]] <- std.error(unlist(ariaverages2.1))
  semari2.2[[as.character(r)]] <- std.error(unlist(ariaverages2.2))
}

#k=2
ARI_table2.1 <- data.frame(
  r = seq(0, 1, by = 0.05),
  average_ARI2.1 = unlist(average_ARI2.1)
)
#k=3
ARI_table2.2 <- data.frame(
  r = seq(0, 1, by = 0.05),
  average_ARI2.2 = unlist(average_ARI2.2)
)
```

Post-Processing - Normalised Mutual Information
```{r}
#The following code is the same as that used above for calculating the normalised mutual information however, inputs are all post-processing
NMIs2.1 <- list()
NMIs2.2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  NMIs2.1[[as.character(r)]] <- list()
  NMIs2.2[[as.character(r)]] <- list()
  for (x in 1:100) {
    NMI_results2.1 <- H2.1_clusters[[as.character(r)]][[as.character(x)]]
    NMI_results2.2 <- H2.2_clusters[[as.character(r)]][[as.character(x)]]
    #k=2
    NMIpredict2.1 <- NMI(NMI_results2.1, True_labels1)
    #k=3
    NMIpredict2.2 <- NMI(NMI_results2.2, True_labels2)
    NMIs2.1[[as.character(r)]][[as.character(x)]] <- NMIpredict2.1
    NMIs2.2[[as.character(r)]][[as.character(x)]] <- NMIpredict2.2
  }
}

average_NMI2.1 <- list()
average_NMI2.2 <- list()
semnmi2.1 <- list()
semnmi2.2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  nmiaverages2.1 <- sapply(1:100, function(x) NMIs2.1[[as.character(r)]][[as.character(x)]])
  nmiaverages2.2 <- sapply(1:100, function(x) NMIs2.2[[as.character(r)]][[as.character(x)]])
  #k=2
  average_NMI2.1[[as.character(r)]] <- mean(unlist(nmiaverages2.1))
  #k=3
  average_NMI2.2[[as.character(r)]] <- mean(unlist(nmiaverages2.2))
  semnmi2.1[[as.character(r)]] <- std.error(unlist(nmiaverages2.1))
  semnmi2.2[[as.character(r)]] <- std.error(unlist(nmiaverages2.2))
}

#k=2
NMI_table2.1 <- data.frame(
  r = seq(0, 1, by = 0.05),
  average_NMI2.1 = unlist(average_NMI2.1)
)
#k=3
NMI_table2.2 <- data.frame(
  r = seq(0, 1, by = 0.05),
  average_NMI2.2 = unlist(average_NMI2.2)
)
```

Paired two sided t-test and SEM
```{r}
#Create a list of purity values pre and post-processing for each value of r
prepurity_values1 <- list()
prepurity_values2 <- list()
postpurity_values1 <- list()
postpurity_values2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  #Pre-processing, k=2
  prepurity1 <- sapply(1:100, function(x) puritylist1[[as.character(r)]][[as.character(x)]]$pur)
  #Pre-processing, k=3
  prepurity2 <- sapply(1:100, function(x) puritylist2[[as.character(r)]][[as.character(x)]]$pur)
  #Post-processing, k=2
  postpurity1 <- sapply(1:100, function(x) puritylist2.1[[as.character(r)]][[as.character(x)]]$pur)
  #Post-processing, k=3
  postpurity2 <- sapply(1:100, function(x) puritylist2.2[[as.character(r)]][[as.character(x)]]$pur)
    prepurity_values1[[as.character(r)]] <- unlist(prepurity1)
    prepurity_values2[[as.character(r)]] <- unlist(prepurity2)
    postpurity_values1[[as.character(r)]] <- unlist(postpurity1)
    postpurity_values2[[as.character(r)]] <- unlist(postpurity2)
}

#Standard error of the mean, for when noise, r = 0
SEM1 <- std.error(prepurity_values1[['0']])
SEM2 <- std.error(prepurity_values2[['0']])
SEM2.1 <- std.error(postpurity_values1[['0']])
SEM2.2 <- std.error(postpurity_values2[['0']])

#T-test to determine if there is a significant difference in purity values pre and pose-processing when noise, r = 0
purityttest1 <- t.test((prepurity_values1[['0']]), (postpurity_values1[['0']]), paired = TRUE, alternative = "two.sided")
purityttest2 <- t.test((prepurity_values2[['0']]), (postpurity_values2[['0']]), paired = TRUE, alternative = "two.sided")

purityttest1
purityttest2
```

Paired two sided t-test and SEM for adjusted rand index
```{r}
#Create a list of purity values pre and post-processing for each value of r
preari_values1 <- list()
preari_values2 <- list()
postari_values1 <- list()
postari_values2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  #Pre-processing, k=2
  preari1 <- sapply(1:100, function(x) ARI1[[as.character(r)]][[as.character(x)]])
  #Pre-processing, k=3
  preari2 <- sapply(1:100, function(x) ARI2[[as.character(r)]][[as.character(x)]])
  #Post-processing, k=2
  postari1 <- sapply(1:100, function(x) ARI2.1[[as.character(r)]][[as.character(x)]])
  #Post-processing, k=3
  postari2 <- sapply(1:100, function(x) ARI2.2[[as.character(r)]][[as.character(x)]])
    preari_values1[[as.character(r)]] <- unlist(preari1)
    preari_values2[[as.character(r)]] <- unlist(preari2)
    postari_values1[[as.character(r)]] <- unlist(postari1)
    postari_values2[[as.character(r)]] <- unlist(postari2)
}

#Standard error of the mean, for when noise, r = 0
ariSEM1 <- std.error(preari_values1[['0']])
ariSEM2 <- std.error(preari_values2[['0']])
ariSEM2.1 <- std.error(postari_values1[['0']])
ariSEM2.2 <- std.error(postari_values2[['0']])

#T-test to determine if there is a significant difference in purity values pre and pose-processing when noise, r = 0
arittest1 <- t.test((preari_values1[['0']]), (postari_values1[['0']]), paired = TRUE, alternative = "two.sided")
arittest2 <- t.test((preari_values2[['0']]), (postari_values2[['0']]), paired = TRUE, alternative = "two.sided")

arittest1
arittest2
```

Paired two sided t-test and SEM for normalised mutual information
```{r}
#Create a list of nmi values pre and post-processing for each value of r
prenmi_values1 <- list()
prenmi_values2 <- list()
postnmi_values1 <- list()
postnmi_values2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  #Pre-processing, k=2
  prenmi1 <- sapply(1:100, function(x) NMIs1[[as.character(r)]][[as.character(x)]])
  #Pre-processing, k=3
  prenmi2 <- sapply(1:100, function(x) NMIs2[[as.character(r)]][[as.character(x)]])
  #Post-processing, k=2
  postnmi1 <- sapply(1:100, function(x) NMIs2.1[[as.character(r)]][[as.character(x)]])
  #Post-processing, k=3
  postnmi2 <- sapply(1:100, function(x) NMIs2.2[[as.character(r)]][[as.character(x)]])
    prenmi_values1[[as.character(r)]] <- unlist(prenmi1)
    prenmi_values2[[as.character(r)]] <- unlist(prenmi2)
    postnmi_values1[[as.character(r)]] <- unlist(postnmi1)
    postnmi_values2[[as.character(r)]] <- unlist(postnmi2)
}

#Standard error of the mean, for when noise, r = 0
nmiSEM1 <- std.error(prenmi_values1[['0']])
nmiSEM2 <- std.error(prenmi_values2[['0']])
nmiSEM2.1 <- std.error(postnmi_values1[['0']])
nmiSEM2.2 <- std.error(postnmi_values2[['0']])

#T-test to determine if there is a significant difference in purity values pre and pose-processing when noise, r = 0
nmittest1 <- t.test((prenmi_values1[['0']]), (postnmi_values1[['0']]), paired = TRUE, alternative = "two.sided")
nmittest2 <- t.test((prenmi_values2[['0']]), (postnmi_values2[['0']]), paired = TRUE, alternative = "two.sided")

nmittest1
nmittest2
```

ttest with noise added - purity
```{r}
#T-test to determine if there is a significant difference in purity values pre and pose-processing for each value of r from 0 to 1, in increments of 0.05.
puritywnoisettest1 <- list()
puritywnoisettest2 <- list()
puritynoisepvalues1 <- list()
puritynoisepvalues2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  puritywnoisettest1[[as.character(r)]] <- t.test(prepurity_values1[[as.character(r)]], postpurity_values1[[as.character(r)]], paired = TRUE, alternative = "two.sided")
  puritywnoisettest2[[as.character(r)]] <- t.test(prepurity_values2[[as.character(r)]], postpurity_values2[[as.character(r)]], paired = TRUE, alternative = "two.sided")
  puritynoisepvalues1[[as.character(r)]] <- puritywnoisettest1[[as.character(r)]]$p.value
  puritynoisepvalues2[[as.character(r)]] <- puritywnoisettest2[[as.character(r)]]$p.value
}

puritynoisepvalues1
puritynoisepvalues2

puritywithnoisettestcomparison <- data.frame(
  r = seq(0, 1, by = 0.05),
  puritywnoisek2 = unlist(puritynoisepvalues1)
    )
puritywithnoisettestcomparison2 <- data.frame(
  r = seq(0, 1, by = 0.05),
  puritywnoisek3 = unlist(puritynoisepvalues2)
    )

plot(puritywithnoisettestcomparison$r[1:11], (-log(puritywithnoisettestcomparison$puritywnoisek2[1:11])), type = "l", col = "purple",
     xlab = "Noise", ylab = "-log(P-value)",
     main = "Leukemia Dataset, k=2", lwd = 2)

plot(puritywithnoisettestcomparison2$r[1:11], (-log(puritywithnoisettestcomparison2$puritywnoisek3[1:11])), type = "l", col = "purple",
     xlab = "Noise", ylab = "-log(P-value)",
     main = "Leukemia Dataset, k=3", lwd = 2)
```

ttest with noise added - ARI
```{r}
#T-test to determine if there is a significant difference in nmi values pre and pose-processing for each value of r from 0 to 1, in increments of 0.05.
ariwnoisettest1 <- list()
ariwnoisettest2 <- list()
arinoisepvalues1 <- list()
arinoisepvalues2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  ariwnoisettest1[[as.character(r)]] <- t.test(preari_values1[[as.character(r)]], postari_values1[[as.character(r)]], paired = TRUE, alternative = "two.sided")
  ariwnoisettest2[[as.character(r)]] <- t.test(preari_values2[[as.character(r)]], postari_values2[[as.character(r)]], paired = TRUE, alternative = "two.sided")
  arinoisepvalues1[[as.character(r)]] <- ariwnoisettest1[[as.character(r)]]$p.value
  arinoisepvalues2[[as.character(r)]] <- ariwnoisettest2[[as.character(r)]]$p.value
}

ariwithnoisettestcomparison <- data.frame(
  r = seq(0, 1, by = 0.05),
  ariwnoisek2 = unlist(arinoisepvalues1)
    )
ariwithnoisettestcomparison2 <- data.frame(
  r = seq(0, 1, by = 0.05),
  ariwnoisek3 = unlist(arinoisepvalues2)
    )

plot(ariwithnoisettestcomparison$r[1:11], (-log(ariwithnoisettestcomparison$ariwnoisek2[1:11])), type = "l", col = "purple",
     xlab = "Noise", ylab = "-log(P-value)",
     main = "Leukemia Dataset, k=2", lwd = 2)

plot(ariwithnoisettestcomparison2$r[1:11], (-log(ariwithnoisettestcomparison2$ariwnoisek3[1:11])), type = "l", col = "purple",
     xlab = "Noise", ylab = "-log(P-value)",
     main = "Leukemia Dataset, k=3", lwd = 2)
```

ttest with noise added - NMI
```{r}
#T-test to determine if there is a significant difference in nmi values pre and pose-processing for each value of r from 0 to 1, in increments of 0.05.
nmiwnoisettest1 <- list()
nmiwnoisettest2 <- list()
nminoisepvalues1 <- list()
nminoisepvalues2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  nmiwnoisettest1[[as.character(r)]] <- t.test(prenmi_values1[[as.character(r)]], postnmi_values1[[as.character(r)]], paired = TRUE, alternative = "two.sided")
  nmiwnoisettest2[[as.character(r)]] <- t.test(prenmi_values2[[as.character(r)]], postnmi_values2[[as.character(r)]], paired = TRUE, alternative = "two.sided")
  nminoisepvalues1[[as.character(r)]] <- nmiwnoisettest1[[as.character(r)]]$p.value
  nminoisepvalues2[[as.character(r)]] <- nmiwnoisettest2[[as.character(r)]]$p.value
}

nmiwithnoisettestcomparison <- data.frame(
  r = seq(0, 1, by = 0.05),
  nmiwnoisek2 = unlist(nminoisepvalues1)
    )
nmiwithnoisettestcomparison2 <- data.frame(
  r = seq(0, 1, by = 0.05),
  nmiwnoisek3 = unlist(nminoisepvalues2)
    )

plot(nmiwithnoisettestcomparison$r[1:11], (-log(nmiwithnoisettestcomparison$nmiwnoisek2[1:11])), type = "l", col = "purple",
     xlab = "Noise", ylab = "-log(P-value)",
     main = "Leukemia Dataset, k=2", lwd = 2)

plot(nmiwithnoisettestcomparison2$r[1:11],(-log(nmiwithnoisettestcomparison2$nmiwnoisek3[1:11])), type = "l", col = "purple",
     xlab = "Noise", ylab = "-log(P-value)",
     main = "Leukemia Dataset, k=3", lwd = 2)
```

Comparison Plots - Purity
```{r}
Accuracycomparison1 <- data.frame(
  r = seq(0, 0.5, by = 0.05),
  Averagepurity1 = unlist(purityaverage1)[1:11],
  Averagepurity2.1 = unlist(purityaverage2.1)[1:11],
  sempurity1 = unlist(sempurity1)[1:11],
  sempurity2.1 = unlist(sempurity2.1)[1:11]
    )

Accuracycomparison2 <- data.frame(
  r = seq(0, 0.5, by = 0.05),
  Averagepurity2 = unlist(purityaverage2)[1:11],
  Averagepurity2.2 = unlist(purityaverage2.2)[1:11],
  sempurity2 = unlist(sempurity2)[1:11],
  sempurity2.2 = unlist(sempurity2.2)[1:11]
    )

#Plot to show the comparison in perfomance before and after normalisation, measured by Purity, for k=2
purity_plot <- ggplot(Accuracycomparison1, aes(x = r)) +
  geom_line(aes(y = Averagepurity1, color = "Pre-normalisation"), size = 1) +
  geom_errorbar(aes(y = Averagepurity1, ymin = Averagepurity1 - sempurity1, ymax = Averagepurity1 + sempurity1), color = "blue", width = 0.05, size = 0.5) +
  geom_line(aes(y = Averagepurity2.1, color = "Post-Normalisation"), size = 1) +
  geom_errorbar(aes(y = Averagepurity2.1, ymin = Averagepurity2.1 - sempurity2.1, ymax = Averagepurity2.1 + sempurity2.1), color = "red", width = 0.05, size = 0.5) +
  labs(title = "Leukemia Dataset, k=2", x = "Noise", y = "Purity") +
  scale_color_manual(name = NULL, values = c("Pre-normalisation" = "blue", "Post-Normalisation" = "red")) + theme_minimal() + theme(plot.title = element_text(hjust = 0.5))
purity_plot + theme(legend.position = "bottom")

#Plot to show the comparison in perfomance before and after normalisation, measured by Purity, for k=3
purity_plot2 <- ggplot(Accuracycomparison2, aes(x = r)) +
  geom_line(aes(y = Averagepurity2, color = "Pre-normalisation"), size = 1) +
  geom_errorbar(aes(y = Averagepurity2, ymin = Averagepurity2 - sempurity2, ymax = Averagepurity2 + sempurity2), color = "blue", width = 0.05, size = 0.5) +
  geom_line(aes(y = Averagepurity2.2, color = "Post-Normalisation"), size = 1) +
  geom_errorbar(aes(y = Averagepurity2.2, ymin = Averagepurity2.2 - sempurity2.2, ymax = Averagepurity2.2 + sempurity2.2), color = "red", width = 0.05, size = 0.5) +
  labs(title = "Leukemia Dataset, k=3", x = "Noise", y = "Purity") +
  scale_color_manual(name = NULL, values = c("Pre-normalisation" = "blue", "Post-Normalisation" = "red")) + theme_minimal()+ theme(plot.title = element_text(hjust = 0.5))
purity_plot2 + theme(legend.position = "bottom")

```

Comparison plots - ARI
```{r}
aricomparison1 <- data.frame(
  r = seq(0, 0.5, by = 0.05),
  Averageari1 = unlist(average_ARI1)[1:11],
  Averageari2.1 = unlist(average_ARI2.1)[1:11],
  semari1 = unlist(semari1)[1:11],
  semari2.1 = unlist(semari2.1)[1:11]
    )

aricomparison2 <- data.frame(
  r = seq(0, 0.5, by = 0.05),
  Averageari2 = unlist(average_ARI2)[1:11],
  Averageari2.2 = unlist(average_ARI2.2)[1:11],
  semari2 = unlist(semari2)[1:11],
  semari2.2 = unlist(semari2.2)[1:11]
    )

#Plot to show the comparison in perfomance before and after normalisation, measured by ARI, for k=2
ari_plot <- ggplot(aricomparison1, aes(x = r)) +
  geom_line(aes(y = Averageari1, color = "Pre-normalisation"), size = 1) +
  geom_errorbar(aes(y = Averageari1, ymin = Averageari1 - semari1, ymax = Averageari1 + semari1), color = "blue", width = 0.05, size = 0.5) +
  geom_line(aes(y = Averageari2.1, color = "Post-Normalisation"), size = 1) +
  geom_errorbar(aes(y = Averageari2.1, ymin = Averageari2.1 - semari2.1, ymax = Averageari2.1 + semari2.1), color = "red", width = 0.05, size = 0.5) +
  labs(title = "Leukemia Dataset, k=2", x = "Noise", y = "ARI") +
  scale_color_manual(name = NULL, values = c("Pre-normalisation" = "blue", "Post-Normalisation" = "red")) + theme_minimal() + theme(plot.title = element_text(hjust = 0.5))
ari_plot + theme(legend.position = "bottom")

#Plot to show the comparison in perfomance before and after normalisation, measured by ARI, for k=3
ari_plot2 <- ggplot(aricomparison2, aes(x = r)) +
  geom_line(aes(y = Averageari2, color = "Pre-normalisation"), size = 1) +
  geom_errorbar(aes(y = Averageari2, ymin = Averageari2 - semari2, ymax = Averageari2 + semari2), color = "blue", width = 0.05, size = 0.5) +
  geom_line(aes(y = Averageari2.2, color = "Post-Normalisation"), size = 1) +
  geom_errorbar(aes(y = Averageari2.2, ymin = Averageari2.2 - semari2.2, ymax = Averageari2.2 + semari2.2), color = "red", width = 0.05, size = 0.5) +
  labs(title = "Leukemia Dataset, k=3", x = "Noise", y = "ARI") +
  scale_color_manual(name = NULL, values = c("Pre-normalisation" = "blue", "Post-Normalisation" = "red")) + theme_minimal() + theme(plot.title = element_text(hjust = 0.5))
ari_plot2 + theme(legend.position = "bottom")
```

Comparison Plots - NMI
```{r}
nmicomparison1 <- data.frame(
  r = seq(0, 0.5, by = 0.05),
  Averagenmi1 = unlist(average_NMI1)[1:11],
  Averagenmi2.1 = unlist(average_NMI2.1)[1:11],
  semnmi1 = unlist(semnmi1)[1:11],
  semnmi2.1 = unlist(semnmi2.1)[1:11]
    )

nmicomparison2 <- data.frame(
  r = seq(0, 0.5, by = 0.05),
  Averagenmi2 = unlist(average_NMI2)[1:11],
  Averagenmi2.2 = unlist(average_NMI2.2)[1:11],
  semnmi2 = unlist(semnmi2)[1:11],
  semnmi2.2 = unlist(semnmi2.2)[1:11]
    )

#Plot to show the comparison in perfomance before and after normalisation, measured by NMI, for k=2
nmi_plot <- ggplot(nmicomparison1, aes(x = r)) +
  geom_line(aes(y = Averagenmi1, color = "Pre-normalisation"), size = 1) +
  geom_errorbar(aes(y = Averagenmi1, ymin = Averagenmi1 - semnmi1, ymax = Averagenmi1 + semnmi1), color = "blue", width = 0.05, size = 0.5) +
  geom_line(aes(y = Averagenmi2.1, color = "Post-Normalisation"), size = 1) +
  geom_errorbar(aes(y = Averagenmi2.1, ymin = Averagenmi2.1 - semnmi2.1, ymax = Averagenmi2.1 + semnmi2.1), color = "red", width = 0.05, size = 0.5, linetype = "dashed") +
  labs(title = "Leukemia Dataset, k=2", x = "Noise", y = "NMI") +
  scale_color_manual(name = NULL, values = c("Pre-normalisation" = "blue", "Post-Normalisation" = "red")) + theme_minimal() + theme(plot.title = element_text(hjust = 0.5))
nmi_plot + theme(legend.position = "bottom")

#Plot to show the comparison in perfomance before and after normalisation, measured by NMI, for k=3
nmi_plot2 <- ggplot(nmicomparison2, aes(x = r)) +
  geom_line(aes(y = Averagenmi2, color = "Pre-normalisation"), size = 1) +
  geom_errorbar(aes(y = Averagenmi2, ymin = Averagenmi2 - semnmi2, ymax = Averagenmi2 + semnmi2), color = "blue", width = 0.05, size = 0.5) +
  geom_line(aes(y = Averagenmi2.2, color = "Post-Normalisation"), size = 1) +
  geom_errorbar(aes(y = Averagenmi2.2, ymin = Averagenmi2.2 - semnmi2.2, ymax = Averagenmi2.2 + semnmi2.2), color = "red", width = 0.05, size = 0.5, linetype = "dashed") +
  labs(title = "Leukemia Dataset, k=3", x = "Noise", y = "NMI") +
  scale_color_manual(name = NULL, values = c("Pre-normalisation" = "blue", "Post-Normalisation" = "red")) + theme_minimal() + theme(plot.title = element_text(hjust = 0.5))
nmi_plot2 + theme(legend.position = "bottom")
```
