---
title: "SRBCT Cancer"
output: html_document
date: "2024-03-05"
---
```{r}
#Required packages
library(Biobase)
library(mclust)
library(clue)
library(pdfCluster)
library(NMF)
library(funtimes)
library(ggplot2)
library(plotrix)
library(fpc)
library(cluster)
library(mclust)
library(aricode)
library(dplyr)
library(corrplot)
```

```{r}
#Read in gene expression data and covert it to matrix formation
exprs <- as.matrix(read.delim("SRBCT.xtrain.txt", header = TRUE, row.names = 1, sep = "\t", as.is = TRUE))

# Data Preprocessing

# Step 1: Replace any NA with the average value of non-NA values across that row

exprs <- t(apply(exprs, 1, function(row) {
  missing_values <- is.na(row)
  if (any(!missing_values)) {
    mean_value <- mean(row[!missing_values], na.rm = TRUE)
    row[missing_values] <- mean_value
  }
  return(row)
}))

# Step 2: Transform(x) to exp(x)

exprs <- exp(exprs)

# Step 3: Remove all genes with zero values across the rows

exprs <- exprs[apply(exprs, 1, function(row) all(row !=0 )), ]

#write out the rownames of exprs to new txt file to ensure that the feature file matches up after pre-processing
vargenes <- writeLines((rownames(exprs)), "C:/Users/Owner/OneDrive/Documents/BI453 - Research Project\\SRBCTfeatures.txt")
```

```{r}
#Read in gene expression data and covert it to matrix formation
pdata <- read.table("SRBCTsamples.txt", row.names = 1, header = FALSE, sep = "\t")
#Read in the file containing feature data i.e. genes
fdata <- read.delim("SRBCTfeatures.txt", row.names = 1, header = FALSE, sep = "\t")

#Makes an expression set from the expression matrix, phenotype data (sample), feature data (gene)
eset <- ExpressionSet(assayData = exprs,
                      phenoData = AnnotatedDataFrame(pdata),
                      featureData = AnnotatedDataFrame(fdata))

#Assign the expression matrix as 'A'
A <- exprs(eset)
```

Ground Truths for Lung Cancer Dataset 
```{r}
#Creating a vector with the ground truths for all samples
groundtruths <- c(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1)

#Function to map cluster predictions to ground truths
unify_labels <- function(predictcluster, T) {
  match(predictcluster, unique(predictcluster))
}
```

```{r}
#Assign the maximum Value of A to 'maxA'.
maxA <- max(A)

#Create a list of 100 matrices for each value of noise 'r', from 0 to 1 in increments of 0.05, where each matrix is generated by adding a scaled random matrix to the original matrix 'A'.
matrix_list <- list()
for (r in seq(0, 1, by = 0.05)) {
  matrix_list[[as.character(r)]] <- list()
  for (x in 1:100) {
    new_matrix <- A + r * (matrix(runif(2308 * 63), nrow = 2308, ncol = 63) * maxA)
    matrix_list[[as.character(r)]][[as.character(x)]] <- new_matrix
  }
}

#Run NMF on each matrix generated above and assign the results to 'nmf_results'.
nmf_results <- list()
for (r in seq(0, 1, by = 0.05)) {
  nmf_results[[as.character(r)]] <- list()
  for (x in 1:100) {
  current_matrix <- matrix_list[[as.character(r)]][[as.character(x)]]
  nmf_result <- nmf(current_matrix, 4, nrun = 2, seed = "random")
  nmf_results[[as.character(r)]][[as.character(x)]] <- nmf_result
  }
}

#Use the predict function to make cluster predictions for each nmf result from above. Use the unify_labels function to map cluster predictions to ground truths.
predictions <- list()
for (r in seq(0, 1, by = 0.05)) {
  predictions[[as.character(r)]] <- list()
  for (x in 1:100) {
  cluster_predictions <- (nmf_results[[as.character(r)]])[[x]]
  clusterpredict <- unify_labels((predict(cluster_predictions)), groundtruths)
  predictions[[as.character(r)]][[as.character(x)]] <- clusterpredict
  }
}
```

Purity
```{r}
#Calculate the purity for cluster predictions made above and assign to 'puritylist'.
puritylist <- list()
for (r in seq(0,1, by = 0.05)) {
  puritylist[[as.character(r)]] <- list()
  for (x in 1:100) {
  purity_results <- predictions[[as.character(r)]][[x]]
  puritymeasure <- purity(groundtruths, purity_results)
  puritylist[[as.character(r)]][[as.character(x)]] <- puritymeasure
  }
}

#Calculate the mean purity and standard error of the mean (SEM) for each value of r across all 100 matrices and assign to 'purityaverage' and 'sempurity'.
purityaverage <- list()
sempurity <- list()
for (r in seq(0, 1, by = 0.05)) {
  purities <- sapply(1:100, function(x) puritylist[[as.character(r)]][[as.character(x)]]$pur)
  purityaverage[[as.character(r)]] <- mean(unlist(purities))
  sempurity[[as.character(r)]] <- std.error(unlist(purities))
}

#Create a table of average purity values for each value of r
Accuracypurity_table <- data.frame(
  r = seq(0, 1, by = 0.05),
  Averagepurity = unlist(purityaverage)
)

Accuracypurity_table
```

Adjusted Rand Index
```{r}
#Calculate the adjusted rand index for cluster predictions made above and assign to 'ARI1' and 'ARI2'
ARI <- list()
for (r in seq(0, 1, by = 0.05)) {
  ARI[[as.character(r)]] <- list()
  for (x in 1:100) {
  ARI_results <- predictions[[as.character(r)]][[as.character(x)]]
  ARIpredict <- adjustedRandIndex(ARI_results, groundtruths)
  ARI[[as.character(r)]][[as.character(x)]] <- ARIpredict
  }
}

average_ARI <- list()
semari <- list()
for (r in seq(0, 1, by = 0.05)) {
  ariaverages <- sapply(1:100, function(x) ARI[[as.character(r)]][[as.character(x)]])
  average_ARI[[as.character(r)]] <- mean(unlist(ariaverages))
  semari[[as.character(r)]] <- std.error(unlist(ariaverages))
}

#Create a table of average adjusted rand index values for each value of r
ARI_table <- data.frame(
  r = seq(0, 1, by = 0.05),
  average_ARI = unlist(average_ARI)
)
```

Normalised Mutual Information
```{r}
#Calculate the normalised mutual information for cluster predictions made above and assign to 'NMIs'
NMIs <- list()
for (r in seq(0, 1, by = 0.05)) {
  NMIs[[as.character(r)]] <- list()
  for (x in 1:100) {
    NMI_results <- predictions[[as.character(r)]][[as.character(x)]]
    NMIpredict <- NMI(NMI_results, groundtruths)
    NMIs[[as.character(r)]][[as.character(x)]] <- NMIpredict
  }
}

#Calculate the mean normalised mutual information for each value of r across all 100 matrices and assign to 'average_NMI'
average_NMI <- list()
semnmi <- list()
for (r in seq(0, 1, by = 0.05)) {
  nmiaverages <- sapply(1:100, function(x) NMIs[[as.character(r)]][[as.character(x)]])
  #k=3
  average_NMI[[as.character(r)]] <- mean(unlist(nmiaverages))
  semnmi[[as.character(r)]] <- std.error(unlist(nmiaverages))
}

NMI_table <- data.frame(
  r = seq(0, 1, by = 0.05),
  average_NMI = unlist(average_NMI)
)

NMI_table
```

Post-Processing Method - Normalisation
```{r}
#Post-processing
#Extract the basis and coefficient matrices, W and H, from the nmf results above 
W_matrices <- list()
W2_matrices <- list()
for(r in seq(0, 1, by = 0.05)) {
  W_matrices[[as.character(r)]] <- list()
  W2_matrices[[as.character(r)]] <- list()
  for (x in 1:100) {
  NMFinput <- (nmf_results[[as.character(r)]])[[x]]
  Wmatrixgen <- basis(NMFinput)
  W_matrices[[as.character(r)]][[as.character(x)]] <- Wmatrixgen
  W2_matrices[[as.character(r)]][[as.character(x)]] <- Wmatrixgen
  }
}

H_matrices <- list()
H2_matrices <- list()
for(r in seq(0, 1, by = 0.05)) {
  H_matrices[[as.character(r)]] <- list()
  H2_matrices[[as.character(r)]] <- list()
  for (x in 1:100) {
  NMFinput <- (nmf_results[[as.character(r)]])[[x]]
  Hmatrixgen <- coef(NMFinput)
  H_matrices[[as.character(r)]][[as.character(x)]] <- Hmatrixgen
  H2_matrices[[as.character(r)]][[as.character(x)]] <- Hmatrixgen
  }
}

#Divide all columns of W by the maximum value in that column and multiply the rows of H by the corresponding value of W
for (r in seq(0, 1, by = 0.05)) {
  for (x in 1:100) {
  max_values <- apply((W2_matrices[[as.character(r)]][[as.character(x)]]), 2, max)
  W2_matrices[[as.character(r)]][[as.character(x)]] <- (W2_matrices[[as.character(r)]][[as.character(x)]]) / max_values
  H2_matrices[[as.character(r)]][[as.character(x)]] <- (H2_matrices[[as.character(r)]][[as.character(x)]]) * max_values
  }
}

#Make cluster predictions using the coefficient matrices H extracted above. A sample j is placed in cluster i if hij is the largest entry in column j.
predicted_clusters <- list()
H2_clusters <- list()
for (r in seq(0, 1, by = 0.05)) {
  for (x in 1:100) {
    H_matrix <- H2_matrices[[as.character(r)]][[as.character(x)]]
    cluster_assignments <- apply(H_matrix, 2, which.max)
    predicted_clusters[[as.character(r)]][[as.character(x)]] <- cluster_assignments
    unifyingclusters <- unify_labels((predicted_clusters[[as.character(r)]][[as.character(x)]]), groundtruths)
    H2_clusters[[as.character(r)]][[as.character(x)]] <- unifyingclusters
  }
}
```

Post-Processing Purity
```{r}
#The following code is the same as that used above for calculating the purity however, inputs are all post-processing
puritylist2 <- list()
for (r in seq(0,1, by = 0.05)) {
  puritylist2[[as.character(r)]] <- list()
  for (x in 1:100) {
  purity_results2 <- H2_clusters[[as.character(r)]][[as.character(x)]]
  puritymeasure2 <- purity(groundtruths, purity_results2)
  puritylist2[[as.character(r)]][[as.character(x)]] <- puritymeasure2
  }
}

purityaverage2 <- list()
sempurity2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  purities2 <- sapply(1:100, function(x) puritylist2[[as.character(r)]][[as.character(x)]]$pur)
  purityaverage2[[as.character(r)]] <- mean(unlist(purities2))
  sempurity2[[as.character(r)]] <- std.error(unlist(purities2))
}

Accuracypurity_table2 <- data.frame(
  r = seq(0, 1, by = 0.05),
  Averagepurity2 = unlist(purityaverage2)
)

Accuracypurity_table2 <- data.frame(
  r = seq(0, 1, by = 0.05),
  Averagepurity2 = unlist(purityaverage2)
)

Accuracypurity_table2
```

```{r}
#Calculate the adjusted rand index for cluster predictions made above, post-normalisation, and assign to 'ARI2'
ARI2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  ARI2[[as.character(r)]] <- list()
  for (x in 1:100) {
  ARI_results2 <- H2_clusters[[as.character(r)]][[as.character(x)]]
  #k=3
  ARIpredict2 <- adjustedRandIndex(ARI_results2, groundtruths)
  ARI2[[as.character(r)]][[as.character(x)]] <- ARIpredict2
  }
}

average_ARI2 <- list()
semari2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  ariaverages2 <- sapply(1:100, function(x) ARI2[[as.character(r)]][[as.character(x)]])
  #k=3
  average_ARI2[[as.character(r)]] <- mean(unlist(ariaverages2))
  semari2[[as.character(r)]] <- std.error(unlist(ariaverages2))
}

#Create a table of average adjusted rand index values for each value of r, when k=2
ARI_table2 <- data.frame(
  r = seq(0, 1, by = 0.05),
  average_ARI2 = unlist(average_ARI2)
)
```

```{r}
#The following code is the same as that used above for calculating the normalised mutual information however, inputs are all post-processing.
NMIs2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  NMIs2[[as.character(r)]] <- list()
  for (x in 1:100) {
    NMI_results2 <- H2_clusters[[as.character(r)]][[as.character(x)]]
    NMIpredict2 <- NMI(NMI_results2, groundtruths)
    NMIs2[[as.character(r)]][[as.character(x)]] <- NMIpredict2
  }
}

#Calculate the mean normalised mutual information for each value of r across all 100 matrices and assign to 'average_NMI2'
average_NMI2 <- list()
semnmi2 <- list()
for (r in seq(0, 1, by = 0.05)) {
  nmiaverages2 <- sapply(1:100, function(x) NMIs2[[as.character(r)]][[as.character(x)]])
  #k=3
  average_NMI2[[as.character(r)]] <- mean(unlist(nmiaverages2))
  semnmi2[[as.character(r)]] <- std.error(unlist(nmiaverages2))
}

NMI_table2 <- data.frame(
  r = seq(0, 1, by = 0.05),
  average_NMI2 = unlist(average_NMI2)
)
```


Paired two sided t-test and SEM for purity
```{r}
prepurity_values <- list()
postpurity_values <- list()
for (r in seq(0, 1, by = 0.05)) {
  prepurity <- sapply(1:100, function(x) puritylist[[as.character(r)]][[as.character(x)]]$pur)
  postpurity <- sapply(1:100, function(x) puritylist2[[as.character(r)]][[as.character(x)]]$pur)
    prepurity_values[[as.character(r)]] <- unlist(prepurity)
    postpurity_values[[as.character(r)]] <- unlist(postpurity)
}

postpurity_values[['0']]

SEM1 <- std.error(prepurity_values[['0']])
SEM2<- std.error(postpurity_values[['0']])

purityttest <- t.test((prepurity_values[['0']]), (postpurity_values[['0']]), paired = TRUE, alternative = "two.sided")

purityttest

```

Paired two sided t-test and SEM for adjusted rand index
```{r}
#Create a list of purity values pre and post-processing for each value of r
preari_values <- list()
postari_values <- list()
for (r in seq(0, 1, by = 0.05)) {
  #Pre-processing, k=3
  preari <- sapply(1:100, function(x) ARI[[as.character(r)]][[as.character(x)]])
  #Post-processing, k=3
  postari <- sapply(1:100, function(x)  ARI2[[as.character(r)]][[as.character(x)]])
  preari_values[[as.character(r)]] <- unlist(preari)
  postari_values[[as.character(r)]] <- unlist(postari)
}

#Standard error of the mean, for when noise, r = 0
ariSEM1 <- std.error(preari_values[['0']])
ariSEM2 <- std.error(postari_values[['0']])

#T-test to determine if there is a significant difference in purity values pre and pose-processing when noise, r = 0
arittest <- t.test((preari_values[['0']]), (postari_values[['0']]), paired = TRUE, alternative = "two.sided")


arittest
```

Paired two sided t-test and SEM for Normalised Mutual Information
```{r}
#Create a list of nmi values pre and post-processing for each value of r
prenmi_values <- list()
postnmi_values <- list()
for (r in seq(0, 1, by = 0.05)) {
  #Pre-processing, k=3
  prenmi <- sapply(1:100, function(x) NMIs[[as.character(r)]][[as.character(x)]])
  #Post-processing, k=3
  postnmi <- sapply(1:100, function(x) NMIs2[[as.character(r)]][[as.character(x)]])
  prenmi_values[[as.character(r)]] <- unlist(prenmi)
  postnmi_values[[as.character(r)]] <- unlist(postnmi)
}

#Standard error of the mean, for when noise, r = 0
nmiSEM1 <- std.error(prenmi_values[['0']])
nmiSEM2 <- std.error(postnmi_values[['0']])

#T-test to determine if there is a significant difference in purity values pre and pose-processing when noise, r = 0
nmittest <- t.test((prenmi_values[['0']]), (postnmi_values[['0']]), paired = TRUE, alternative = "two.sided")


nmittest
```

```{r}
#T-test to determine if there is a significant difference in purity values pre and pose-processing for each value of r from 0 to 1, in increments of 0.05.
puritywnoisettest <- list()
puritynoisepvalues <- list()
for (r in seq(0, 1, by = 0.05)) {
  puritywnoisettest[[as.character(r)]] <- t.test(prepurity_values[[as.character(r)]], postpurity_values[[as.character(r)]], paired = TRUE, alternative = "two.sided")
  puritynoisepvalues[[as.character(r)]] <- puritywnoisettest[[as.character(r)]]$p.value
}

puritywithnoisettestcomparison <- data.frame(
  r = seq(0, 1, by = 0.05),
  puritywnoise = unlist(puritynoisepvalues)
    )

plot(puritywithnoisettestcomparison$r[1:11], (-log(puritywithnoisettestcomparison$puritywnoise[1:11])), type = "l", col = "purple",
     xlab = "Noise", ylab = "-log(P-value)",
     main = "SRBCT, k=4", lwd = 2)
```

```{r}
#T-test to determine if there is a significant difference in ari values pre and pose-processing for each value of r from 0 to 1, in increments of 0.05.
ariwnoisettest <- list()
arinoisepvalues <- list()
for (r in seq(0, 1, by = 0.05)) {
  ariwnoisettest[[as.character(r)]] <- t.test(preari_values[[as.character(r)]], postari_values[[as.character(r)]], paired = TRUE, alternative = "two.sided")
  arinoisepvalues[[as.character(r)]] <- ariwnoisettest[[as.character(r)]]$p.value
}

ariwithnoisettestcomparison <- data.frame(
  r = seq(0, 1, by = 0.05),
  ariwnoise = unlist(arinoisepvalues)
    )

plot(ariwithnoisettestcomparison$r[1:11], (-log(ariwithnoisettestcomparison$ariwnoise[1:11])), type = "l", col = "purple",
     xlab = "Noise", ylab = "-log(P-value)",
     main = "SRBCT, k=4", lwd = 2)
```

```{r}
#T-test to determine if there is a significant difference in nmi values pre and pose-processing for each value of r from 0 to 1, in increments of 0.05.
nmiwnoisettest <- list()
nminoisepvalues <- list()
for (r in seq(0, 1, by = 0.05)) {
  nmiwnoisettest[[as.character(r)]] <- t.test(prenmi_values[[as.character(r)]], postnmi_values[[as.character(r)]], paired = TRUE, alternative = "two.sided")
  nminoisepvalues[[as.character(r)]] <- nmiwnoisettest[[as.character(r)]]$p.value
}

nmiwithnoisettestcomparison <- data.frame(
  r = seq(0, 1, by = 0.05),
  nmiwnoise = unlist(nminoisepvalues)
    )

plot(nmiwithnoisettestcomparison$r[1:11], (-log(nmiwithnoisettestcomparison$nmiwnoise[1:11])), type = "l", col = "purple",
     xlab = "Noise", ylab = "-log(P-value)",
     main = "SRBCT, k=4", lwd = 2)
```

Comparison plots
```{r}
#Comparison for purity
puritycomparison <- data.frame(
  r = seq(0, 0.5, by = 0.05),
  Averagepurity1 = unlist(purityaverage)[1:11],
  Averagepurity2 = unlist(purityaverage2)[1:11],
  sempurity = unlist(sempurity)[1:11],
  sempurity2 = unlist(sempurity2)[1:11]
    )

#Plot to show the comparison in perfomance before and after normalisation, measured by Purity
purity_plot <- ggplot(puritycomparison, aes(x = r)) +
  geom_line(aes(y = Averagepurity1, color = "Pre-normalisation"), size = 1) +
  geom_errorbar(aes(y = Averagepurity1, ymin = Averagepurity1 - sempurity, ymax = Averagepurity1 + sempurity), color = "blue", width = 0.05, size = 0.5) +
  geom_line(aes(y = Averagepurity2, color = "Post-Normalisation"), size = 1) +
  geom_errorbar(aes(y = Averagepurity2, ymin = Averagepurity2 - sempurity2, ymax = Averagepurity2 + sempurity2), color = "red", width = 0.05, size = 0.5) +
  labs(title = "SRBCT dataset, k=4", x = "Noise", y = "Purity") +
  scale_color_manual(name = NULL, values = c("Pre-normalisation" = "blue", "Post-Normalisation" = "red")) + theme_minimal() + theme(plot.title = element_text(hjust = 0.5))
purity_plot + theme(legend.position = "bottom")

#Comparison for ARI
aricomparison <- data.frame(
  r = seq(0, 0.5, by = 0.05),
  Averageari1 = unlist(average_ARI)[1:11],
  Averageari2 = unlist(average_ARI2)[1:11],
  semari1 = unlist(semari)[1:11],
  semari2 = unlist(semari2)[1:11]
    )

#Plot to show the comparison in perfomance before and after normalisation, measured by ARI
ari_plot <- ggplot(aricomparison, aes(x = r)) +
  geom_line(aes(y = Averageari1, color = "Pre-normalisation"), size = 1) +
  geom_errorbar(aes(y = Averageari1, ymin = Averageari1 - semari1, ymax = Averageari1 + semari1), color = "blue", width = 0.05, size = 0.5) +
  geom_line(aes(y = Averageari2, color = "Post-Normalisation"), size = 1) +
  geom_errorbar(aes(y = Averageari2, ymin = Averageari2 - semari2, ymax = Averageari2 + semari2), color = "red", width = 0.05, size = 0.5) +
  labs(title = "SRBCT Dataset, k=4", x = "Noise", y = "ARI") +
  scale_color_manual(name = NULL, values = c("Pre-normalisation" = "blue", "Post-Normalisation" = "red")) + theme_minimal() + theme(plot.title = element_text(hjust = 0.5))
ari_plot + theme(legend.position = "bottom")

#Comparison for NMI
nmicomparison <- data.frame(
  r = seq(0, 0.5, by = 0.05),
  Averagenmi1 = unlist(average_NMI)[1:11],
  Averagenmi2 = unlist(average_NMI2)[1:11],
  semnmi1 = unlist(semnmi)[1:11],
  semnmi2 = unlist(semnmi2)[1:11]
    )

#Plot to show the comparison in perfomance before and after normalisation, measured by NMI
nmi_plot <- ggplot(nmicomparison, aes(x = r)) +
  geom_line(aes(y = Averagenmi1, color = "Pre-normalisation"), size = 1) +
  geom_errorbar(aes(y = Averagenmi1, ymin = Averagenmi1 - semnmi1, ymax = Averagenmi1 + semnmi1), color = "blue", width = 0.05, size = 0.5) +
  geom_line(aes(y = Averagenmi2, color = "Post-Normalisation"), size = 1) +
  geom_errorbar(aes(y = Averagenmi2, ymin = Averagenmi2 - semnmi2, ymax = Averagenmi2 + semnmi2), color = "red", width = 0.05, size = 0.5, linetype = "dashed") +
  labs(title = "SRBCT, k=4", x = "Noise", y = "NMI") +
  scale_color_manual(name = NULL, values = c("Pre-normalisation" = "blue", "Post-Normalisation" = "red")) + theme_minimal() + theme(plot.title = element_text(hjust = 0.5))
nmi_plot + theme(legend.position = "bottom")
```